Summary

[TOC]

# 考点：

## 一、C++

### 1. 内存管理

#### 1.1 c++内存分区

#### 1.2 静态变量、全局变量

#### 1.3 c++分配内存的函数

#### 1.4 什么是野指针、悬空指针

#### 1.5 什么是内存泄漏

#### 1.6 什么是智能指针

#### 1.7 stl容器的机制

##### 1.7.1 vector

##### 1.7.2 unordered_map 和 map / unordered_set 和 set

#### 1.8 内存对齐

#### 1.9 类及类中成员的内存大小

#### 1.10 结构体和类的区别



### 2. 面向对象

#### 2.1 构造函数

#### 2.2 封装、继承、多态

#### 2.3 虚函数

#### 2.4 纯虚函数

#### 2.5 构造函数和析构函数可以为虚函数吗

#### 2.6 

### 3. 左值右值



## 二、操作系统



## 三、计算机网络



## 四、c#



## 五、图形学



## 六、项目



## 2025.8.3

### 1. c++内存分区

c++的内存分为：栈、堆、静态区/全局区、常量区、二进制代码段。

1. 栈：主要用于存储局部变量，函数的返回值和参数，函数调用上下文，大小固定，一般是8MB。编译器自己分配和释放。内存分配连续。

2. 堆：主要用于存储使用malloc、new创建的变量，程序中动态分配的空间，由程序员分配和释放。内存分配不连续。

3. 静态区/全局区：用于存储静态变量、全局变量。

4. 常量区：存储字符串常量、const常量。

```c++
const char* str = "Hello";  // "Hello"在常量区
const int MAX = 100;        // MAX可能在常量区或由编译器优化
```

5. 二进制代码段：存储程序的执行代码、通常是只读的。

![image](https://img2023.cnblogs.com/blog/1907914/202308/1907914-20230809165505446-1168172160.png)

### 2. 静态变量、全局变量

静态变量：局部静态变量、全局静态变量、类静态变量。

| **特性**         | **局部静态变量** (函数内部)           | **全局静态变量** (文件作用域) | **类静态变量** (类作用域)                                    |
| :--------------- | :------------------------------------ | :---------------------------- | :----------------------------------------------------------- |
| **何时分配内存** | 第一次执行到声明处时初始化 (线程安全) | 程序启动时 (main函数之前)     | 程序启动时 (main函数之前)                                    |
| **内存位置**     | 全局/静态存储区 (.bss/.data)          | 全局/静态存储区 (.bss/.data)  | 全局/静态存储区 (.bss/.data)                                 |
| **生命周期**     | 程序整个运行期间                      | 程序整个运行期间              | 程序整个运行期间                                             |
| **作用域**       | 声明所在的函数内部                    | 声明所在的文件内部            | 整个程序 (但访问受访问权限限制)                              |
| **谁可以调用**   | 仅声明所在的函数                      | 同一文件内的函数              | 类作用域内： • 类成员函数 • 类作用域外的友元函数             |
| **调用方式**     | 函数内部直接使用变量名                | 文件内直接使用变量名          | 类外：`ClassName::varName` 类内：直接使用或`ClassName::varName` |
| **初始化**       | 第一次执行时初始化 (C++11起线程安全)  | 程序启动时初始化 (静态初始化) | 类外单独定义时初始化                                         |
| **销毁时机**     | 程序结束时逆序销毁                    | 程序结束时逆序销毁            | 程序结束时逆序销毁                                           |



### 3. c++分配内存的函数

| **特性**     | **malloc/free** (C语言)              | **new/delete** (C++)                       | **相同点**         |
| :----------- | :----------------------------------- | :----------------------------------------- | :----------------- |
| **语言性质** | 标准库函数 (`<cstdlib>`)             | C++运算符                                  | 都用于动态内存管理 |
| **内存来源** | 堆内存                               | 堆内存                                     | 都从堆上分配内存   |
| **内存大小** | 需显式指定字节数：`malloc(size)`     | 自动计算类型大小：`new T`                  |                    |
| **返回值**   | 返回`void*` (需类型转换)             | 返回类型化指针                             |                    |
| **构造函数** | 不调用构造函数                       | 调用构造函数                               |                    |
| **析构函数** | 不调用析构函数                       | 调用析构函数                               |                    |
| **初始化**   | 分配后需手动初始化                   | 支持初始化：`new T(值)` 或 `new T{值}`     |                    |
| **失败处理** | 返回`NULL`                           | 抛出`std::bad_alloc`异常                   | 都需要检查分配结果 |
| **数组处理** | `malloc(n*sizeof(T))`                | `new T[n]` (自动计算大小)                  | 都支持数组分配     |
| **数组释放** | `free(ptr)`                          | `delete[] ptr` (必须匹配)                  | 都需要释放内存     |
| **重载能力** | 不可重载                             | 可重载运算符(全局或类特定)                 |                    |
| **内存调整** | 支持`realloc`调整内存大小            | 无直接调整机制(需手动重新分配)             |                    |
| **类型安全** | 类型不安全(返回void*)                | 类型安全                                   |                    |
| **异常安全** | 不保证                               | 提供强异常安全性                           |                    |
| **多态支持** | 不支持多态对象析构                   | 正确调用派生类析构函数                     |                    |
| **内存对齐** | 基础对齐                             | 支持对齐控制：`alignas` 和 `aligned_alloc` |                    |
| **适用场景** | C语言程序、与C兼容代码、原始内存分配 | C++面向对象程序、需要构造/析构的场景       | 都需要成对使用     |

new/delete的过程

new：调用malloc、调用构造函数

delete：调用析构函数、调用free

### 4. 什么是野指针、悬空指针

| **特性**        | **野指针**                 | **悬空指针**                                                |
| :-------------- | :------------------------- | :---------------------------------------------------------- |
| **定义**        | 未初始化的指针             | 指向已释放内存的指针                                        |
| **指针值**      | 随机地址                   | 原有效地址（但已无效）                                      |
| **产生原因**    | 声明后未初始化             | 1. 内存释放后未置空 2. 返回局部变量地址 3. 对象生命周期结束 |
| **危害程度**    | ★★★★★（极高风险）          | ★★★★☆（高风险）                                             |
| **典型场景**    | 未初始化的指针变量         | delete/free后继续使用                                       |
| **调试难度**    | 较易发现（常导致立即崩溃） | 较难发现（可能间歇性出现）                                  |
| **解决方法**    | 声明时初始化为nullptr      | 1. 释放后立即置空 2. 使用智能指针                           |
| **C++示例**     | `int* p;`                  | `int* p = new int; delete p;`                               |
| **现代C++防护** | 总是初始化                 | 使用unique_ptr/shared_ptr                                   |

### 5. 什么是内存泄漏

内存泄漏（Memory Leak）是指**程序在动态分配内存后，失去对该内存区域的控制权，无法再访问或释放该内存**的现象。当程序持续运行且反复发生内存泄漏时，可用内存会逐渐减少，最终可能导致程序崩溃或系统性能下降。

### 6. 什么是智能指针

- 智能指针是C++11引入的**自动化内存管理工具**，通过RAII（Resource Acquisition Is Initialization）模式管理动态分配的内存。它们在析构时自动释放内存，有效防止内存泄漏和悬空指针问题。

- RAII（Resource Acquisition Is Initialization）是C++的核心编程理念，直译为"**资源获取即初始化**"。其核心思想是将**资源生命周期**与**对象生命周期**绑定：

1. **构造函数获取资源**（分配内存、打开文件、加锁等）
2. **析构函数释放资源**（释放内存、关闭文件、解锁等）
3. **利用栈对象自动析构的特性确保资源释放**

- 三大智能指针对比

| 类型         | 所有权   | 复制行为         | 性能       | 适用场景                     |
| :----------- | :------- | :--------------- | :--------- | :--------------------------- |
| `unique_ptr` | 独占     | 禁止复制，可移动 | 接近裸指针 | 单一所有权的资源管理         |
| `shared_ptr` | 共享     | 引用计数增加     | 有额外开销 | 需要多个所有者共享资源       |
| `weak_ptr`   | 无所有权 | 不增加引用计数   | 轻量       | 解决`shared_ptr`循环引用问题 |

- 智能指针的内存分配涉及**两个独立部分**：

1. **智能指针对象本身**：在**栈**上分配（作为局部变量时）或**静态/全局存储区**
2. **智能指针管理的资源**：在**堆**上分配

- RAII实现要点

1. **封装资源**：将资源封装在类中
2. **构造函数获取**：在构造函数中获取资源
3. **析构函数释放**：在析构函数中释放资源
4. **禁止拷贝**：通常禁用拷贝构造函数和拷贝赋值

- 循环引用

```c++
struct ListNode {
    std::shared_ptr<ListNode> next;
    std::shared_ptr<ListNode> prev; // 导致循环引用
};

auto node1 = std::make_shared<ListNode>();
auto node2 = std::make_shared<ListNode>();

node1->next = node2;  // node2引用计数=2
node2->prev = node1;  // node1引用计数=2
// 离开作用域后计数为1，内存泄漏！
```



### 7. stl容器的机制

#### 7.1 vector

1. **维护了三个迭代器，begin()   end()   finish(); **

begin()：指向容器第一个元素

end()：指向容器最后一个元素的下一个元素

finish()：指向容器内存的末尾位置

2. **初始容量分配**

- 默认构造时的内存分配

当使用**默认构造函数**创建 vector 时：

```c++
std::vector<int> v;  // 默认构造
```

​		**不分配任何内存**（大多数现代实现中）

​		`size() = 0`

​		`capacity() = 0`

​		首次插入元素时才进行首次分配

- 指定初始大小的构造

```c++
std::vector<int> v(5);  // 包含5个元素
```

​		**分配内存**：足够存储5个int

​		**值初始化**：每个元素被初始化为0（对于基本类型）

​		`size() = 5`

​		`capacity() >= 5`（具体取决于实现）

- 指定初始大小和值的构造

```c++
std::vector<int> v(5, 42);  // 5个元素，每个都是42
```

​		**分配内存**：足够存储5个int

​		**填充值**：每个元素被初始化为42

​		`size() = 5`

​		`capacity() >= 5`

- 通过初始化列表构造

```c++
std::vector<int> v{1, 2, 3, 4, 5};
```

​		**分配内存**：足够存储5个int

​		**初始化**：用列表中的值初始化元素

​		`size() = 5`

​		`capacity() >= 5`（通常等于size）

3. **扩容机制**

​        C++中的`std::vector`采用动态连续的倍增扩容机制：==当插入元素导致当前容量不足时，vector会按增长因子（通常为1.5或2.0）申请更大的新内存块，将旧元素移动/拷贝到新空间后释放原内存==。这种设计使得插入操作的均摊时间复杂度为O(1)，但扩容会导致所有迭代器失效。实际开发中应通过`reserve()`预分配来减少频繁扩容的开销。

### 8. 内存对齐

**规则1**：结构体第一个成员的偏移量（offset）为0，每个成员必须满足其对齐要求。

**规则2**：结构体的总大小必须是其最大对齐数的整数倍（不足需补齐）。

**规则3**：如果结构体嵌套，内层结构体的对齐值是其最大成员的大小。

**规则4：**每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始

内存对齐的好处：

现代计算机的处理器在读取内存数据时，通常以特定的大小（如字长）为单位进行读取。如果数据是按照内存对齐的方式存储，==处理器可以在一次内存访问操作中完整地读取数据==。例如，对于一个 32 位处理器，如果一个 4 字节的整数是内存对齐的，处理器可以用一次内存读取操作就获取到这个数据。但如果这个整数没有对齐，比如存储在一个不能被 4 整除的地址上，处理器可能需要进行两次内存读取操作，然后再将读取到的数据拼接起来才能获取完整的整数数据。这无疑会降低读取数据的速度。

### 9. 类及类中成员的内存大小

- 空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

- 类内部的成员变量：
  普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
  static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。

- 类内部的成员函数：
  普通函数：不占用内存。
  虚函数：要占用4个字节（32位系统）或8个字节（64位系统），用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。

- C++编译系统中，数据和函数是分开存放的(函数放在代码区；数据主要放在栈区或堆区，静态/全局区以及文字常量区也有)，实例化不同对象时，只给数据分配空间，各个对象调用函数时都都跳转到(内联函数例外)找到函数在代码区的入口执行，可以节省拷贝多份代码的空间

数据主要放在栈区或堆区，有可能是堆，也有可能是栈。这取决于实例化对象的方式：

```c++
A a1 = new A(); //堆
A a2; //栈
```

- 类的静态成员变量编译时被分配到静态/全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间。

- 内联函数(声明和定义都要加inline)也是存放在代码区，在编译阶段，编译器会用内联函数的代码替换掉函数，避免了函数跳转和保护现场的开销。不要将成员函数的这种存储方式和inline(内联)函数的概念混淆。不要误以为用inline声明(或默认为inline)的成员函数，其代码段占用对象的存储空间，而不用inline声明的成员函数，其代码段不占用对象的存储空间。不论是否用inline声明(或默认为inline)，成员函数的代码段都不占用对象的存储空间。用inline声明的作用是在编译时期，将函数的代码段复制插人到函数调用点，而若不用inline声明，在调用该函数时，流程转去函数代码段的入口地址，在执行完该函数代码段后，流程返回函数调用点。inline与成员函数是否占用对象的存储空间无关

原文链接：https://blog.csdn.net/luolaihua2018/article/details/110736211

### 10. 结构体和类的区别

默认访问权限，结构体默认访问权限是public，类对象默认访问权限是private

